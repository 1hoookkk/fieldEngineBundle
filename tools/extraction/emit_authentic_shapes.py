#!/usr/bin/env python3
import argparse
import json
import os
from typing import List, Tuple


def load_shapes(path: str) -> Tuple[int, List[dict]]:
	with open(path, 'r', encoding='utf-8') as f:
		data = json.load(f)
	if 'sampleRateRef' not in data or 'shapes' not in data:
		raise ValueError(f"Invalid schema in {path}; expected keys sampleRateRef, shapes")
	sr = int(data['sampleRateRef'])
	shapes = data['shapes']
	return sr, shapes


def polar12_from_shape(shape_obj: dict) -> List[float]:
	poles = shape_obj.get('poles', [])
	if len(poles) < 6:
		raise ValueError(f"Shape '{shape_obj.get('id','')}' has {len(poles)} poles; expected 6")
	out: List[float] = []
	for i in range(6):
		r = float(poles[i].get('r', 0.95))
		th = float(poles[i].get('theta', 0.0))
		# clamp r to valid range
		r = 0.0 if r < 0.0 else (0.999999 if r > 0.999999 else r)
		out.extend([r, th])
	return out


def emit_header(shapesA: List[List[float]], shapesB: List[List[float]], ids: List[str], out_header: str, ref_sr: int) -> None:
	n = len(shapesA)
	# Build concatenated shapes: first all A, then all B
	all_shapes = shapesA + shapesB
	# MORPH_PAIRS map pair index to (A_index, B_index)
	pairs = [(i, i + n) for i in range(n)]

	lines: List[str] = []
	lines.append("#pragma once")
	lines.append("// Autogenerated by tools/extraction/emit_authentic_shapes.py")
	lines.append(f"// Reference sample rate: {ref_sr} Hz")
	lines.append("")
	lines.append(f"static const int AUTHENTIC_EMU_SAMPLE_RATE_REF = {ref_sr};")
	lines.append(f"static const int AUTHENTIC_EMU_NUM_SHAPES = {len(all_shapes)};")
	lines.append(f"static const int AUTHENTIC_EMU_NUM_PAIRS = {n};")
	lines.append("")
	lines.append(f"static const float AUTHENTIC_EMU_SHAPES[{len(all_shapes)}][12] = {{")
	for idx, shp in enumerate(all_shapes):
		vals = ", ".join(f"{v:.9g}f" for v in shp)
		lines.append(f"\t{{ {vals} }}, // {idx:3d} {'A' if idx < n else 'B'}:{ids[idx if idx < n else idx - n]}")
	lines.append("};")
	lines.append("")
	lines.append(f"static const int MORPH_PAIRS[{len(pairs)}][2] = {{")
	for a, b in pairs:
		lines.append(f"\t{{ {a}, {b} }}, // {ids[a]}")
	lines.append("};")
	lines.append("")
	# Optional: expose ids (for debugging)
	lines.append(f"static const char* AUTHENTIC_EMU_IDS[{len(ids)}] = {{")
	for s in ids:
		escaped = s.replace('"', '\\"')
		lines.append(f"\t\"{escaped}\",")
	lines.append("};")
	content = "\n".join(lines) + "\n"
	os.makedirs(os.path.dirname(out_header), exist_ok=True)
	with open(out_header, 'w', encoding='utf-8') as f:
		f.write(content)


def emit_compiled_artifacts(shapesA: List[List[float]], shapesB: List[List[float]], ids: List[str], out_dir: str, ref_sr: int) -> None:
	os.makedirs(out_dir, exist_ok=True)
	# Consolidated JSON
	compiled = {
		"sampleRateRef": ref_sr,
		"count": len(ids),
		"pairs": [
			{
				"id": ids[i],
				"A": shapesA[i],
				"B": shapesB[i]
			} for i in range(len(ids))
		]
	}
	with open(os.path.join(out_dir, 'compiled_shapes.json'), 'w', encoding='utf-8') as f:
		json.dump(compiled, f, indent=2)
	# CSVs: one for A, one for B, columns: id, r0, th0, r1, th1, ... r5, th5
	def write_csv(path: str, shapes: List[List[float]]):
		with open(path, 'w', encoding='utf-8') as f:
			f.write('id,' + ','.join([f"r{i},theta{i}" for i in range(6)]) + '\n')
			for i, shp in enumerate(shapes):
				row = [ids[i]] + [f"{v:.9g}" for v in shp]
				f.write(','.join(row) + '\n')
	write_csv(os.path.join(out_dir, 'shapes_A.csv'), shapesA)
	write_csv(os.path.join(out_dir, 'shapes_B.csv'), shapesB)


def main():
	ap = argparse.ArgumentParser()
	ap.add_argument('fileA', help='Path to audity_shapes_A_48k.json')
	ap.add_argument('fileB', help='Path to audity_shapes_B_48k.json')
	ap.add_argument('--out-header', default=os.path.join('libs', 'emu', 'shapes', 'EMUAuthenticTables.h'))
	ap.add_argument('--out-dir', default=os.path.join('libs', 'emu', 'shapes', 'compiled'))
	args = ap.parse_args()

	refA, shapesA_raw = load_shapes(args.fileA)
	refB, shapesB_raw = load_shapes(args.fileB)
	if refA != refB:
		raise ValueError(f"sampleRateRef mismatch: {refA} vs {refB}")

	idsA = [s.get('id', '') for s in shapesA_raw]
	idsB = [s.get('id', '') for s in shapesB_raw]
	if idsA != idsB:
		raise ValueError(f"Shape id lists differ between A and B.\nA: {idsA}\nB: {idsB}")

	ids = idsA
	# Convert to polar12 lists
	shapesA = [polar12_from_shape(s) for s in shapesA_raw]
	shapesB = [polar12_from_shape(s) for s in shapesB_raw]

	emit_header(shapesA, shapesB, ids, args.out_header, refA)
	emit_compiled_artifacts(shapesA, shapesB, ids, args.out_dir, refA)
	print(f"Wrote {args.out_header}")
	print(f"Wrote compiled artifacts to {args.out_dir}")


if __name__ == '__main__':
	main()
