#include "MorphEngineProcessor.h"































#include "MorphEngineEditor.h"































































//==============================================================================































MorphEngineAudioProcessor::MorphEngineAudioProcessor()































     : AudioProcessor (BusesProperties()































                     #if ! JucePlugin_IsMidiEffect































                      #if ! JucePlugin_IsSynth































                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)































                      #endif































                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)































                     #endif































                       )































{































    // Listen for style changes so we can push macro targets































    apvts.addParameterListener("style.variant", this);































}































































MorphEngineAudioProcessor::~MorphEngineAudioProcessor()































{































    apvts.removeParameterListener("style.variant", this);































}































































//==============================================================================































const juce::String MorphEngineAudioProcessor::getName() const































{































    return JucePlugin_Name;































}































































bool MorphEngineAudioProcessor::acceptsMidi() const































{































   #if JucePlugin_WantsMidiInput































    return true;































   #else































    return false;































   #endif































}































































bool MorphEngineAudioProcessor::producesMidi() const































{































   #if JucePlugin_ProducesMidiOutput































    return true;































   #else































    return false;































   #endif































}































































bool MorphEngineAudioProcessor::isMidiEffect() const































{































   #if JucePlugin_IsMidiEffect































    return true;































   #else































    return false;































   #endif































}































































double MorphEngineAudioProcessor::getTailLengthSeconds() const































{































    return 0.0;































}































































int MorphEngineAudioProcessor::getNumPrograms()































{































    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,































                // so this should be at least 1, even if you're not really implementing programs.































}































































int MorphEngineAudioProcessor::getCurrentProgram()































{































    return 0;































}































































void MorphEngineAudioProcessor::setCurrentProgram (int index)































{































    (void)index;































}































































const juce::String MorphEngineAudioProcessor::getProgramName (int index)































{































    (void)index;































    return {};































}































































void MorphEngineAudioProcessor::changeProgramName (int index, const juce::String& newName)































{































    (void)index;































    (void)newName;































}































































//==============================================================================































void MorphEngineAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)







{







    setSmootherTimes(sampleRate);















    morphLFO.prepare(sampleRate);







    morphLFO.setRateHz(*apvts.getRawParameterValue("auto.morphRateHz"));







    morphEnv.prepare(sampleRate);







    smAutoDepth.setCurrentAndTargetValue(apvts.getRawParameterValue("auto.morphDepth")->load());







    lastIsPlaying = false;















    zbridge_.setSampleRate((float) sampleRate);







    zbridge_.reset();















    // Load default model (Vowel)







    auto* rpModel = apvts.getRawParameterValue("zplane.model");







    int modelIndex = (int) rpModel->load();







    zbridge_.loadModelByBinarySymbol(modelIndex);







}







































































void MorphEngineAudioProcessor::releaseResources()































{































    // When playback stops, you can use this as an opportunity to free up any































    // spare memory, etc.































}































































#ifndef JucePlugin_PreferredChannelConfigurations































bool MorphEngineAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const































{































  #if JucePlugin_IsMidiEffect































    juce::ignoreUnused (layouts);































    return true;































  #else































    // This is the place where you check if the layout is supported.































    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()































     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())































        return false;































































    // This checks if the input layout matches the output layout































   #if ! JucePlugin_IsSynth































    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())































        return false;































   #endif































































    return true;































  #endif































}































#endif































































void MorphEngineAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)



{



    juce::ScopedNoDenormals noDenormals;



    auto totalNumInputChannels  = getTotalNumInputChannels();



    auto totalNumOutputChannels = getTotalNumOutputChannels();







    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)



        buffer.clear(i, 0, buffer.getNumSamples());







    const int numCh = buffer.getNumChannels();



    const int n     = buffer.getNumSamples();







    auto* rpModel = apvts.getRawParameterValue("zplane.model");



    const int modelIndex = (int) rpModel->load();







    const float userMorph = apvts.getRawParameterValue("zplane.morph")->load();



    const bool autoEnabled = (*apvts.getRawParameterValue("auto.morph") > 0.5f);







    updateAutoMorphRateFromHostTempo();







    smAutoDepth.setTargetValue(apvts.getRawParameterValue("auto.morphDepth")->load());



    const float depth = smAutoDepth.getNextValue();







    float lfo = 0.0f;



    if (autoEnabled && n > 0)



        lfo = morphLFO.evalAndAdvance(n) * depth;







    float env = 0.0f;



    if (autoEnabled && envAssistMix > 0.0f && buffer.getNumChannels() > 0)



    {



        const float centred = morphEnv.processBlock(buffer) - 0.2f;



        env = juce::jlimit(-1.0f, 1.0f, centred * envAssistMix) * depth;



    }







    const float morphTarget = juce::jlimit(0.0f, 1.0f, userMorph + lfo + env);







    smMorph.setTargetValue(morphTarget);



    smCutoff.setTargetValue(apvts.getRawParameterValue("zplane.cutoff")->load());



    smReso.setTargetValue(apvts.getRawParameterValue("zplane.resonance")->load());



    smMix.setTargetValue(apvts.getRawParameterValue("style.mix")->load());







    for (int i = 0; i < n; ++i)



    {



        const float morph  = smMorph.getNextValue();



        const float cutoff = smCutoff.getNextValue();



        const float reso   = smReso.getNextValue();



        const float mix    = smMix.getNextValue();







        pe::ZPlaneParams p {



            modelIndex,



            morph,



            reso,



            cutoff,



            mix



        };







        float* chans[2] = {



            buffer.getWritePointer(0) + i,



            numCh > 1 ? buffer.getWritePointer(1) + i : nullptr



        };







        zbridge_.process(chans, numCh, 1, p);



    }



}































































//==============================================================================































bool MorphEngineAudioProcessor::hasEditor() const































{































    return true; // (change this to false if you choose to not supply an editor)































}































































juce::AudioProcessorEditor* MorphEngineAudioProcessor::createEditor()































{































    return new MorphEngineAudioProcessorEditor (*this);































}































































//==============================================================================































void MorphEngineAudioProcessor::getStateInformation (juce::MemoryBlock& destData)































{































    auto state = apvts.copyState();































    std::unique_ptr<juce::XmlElement> xml (state.createXml());































    copyXmlToBinary (*xml, destData);































}































































void MorphEngineAudioProcessor::setStateInformation (const void* data, int sizeInBytes)































{































    std::unique_ptr<juce::XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));































    if (xmlState == nullptr)































        return;































































    auto vt = juce::ValueTree::fromXml (*xmlState);































    if (! vt.isValid())































        return;































































    // Copy properties into the expected root type to tolerate tag name changes































    juce::ValueTree newState { apvts.state.getType() };































    newState.copyPropertiesAndChildrenFrom(vt, nullptr);































































    // Lightweight migration: accept legacy parameter IDs if encountered































    auto map01 = [](juce::var v) -> float {































        const float f = (float) v;































        return f > 1.001f ? (f * 0.01f) : f; // accept 0..100 or 0..1































    };































































    if (! newState.hasProperty("zplane.morph") && newState.hasProperty("morph"))































        newState.setProperty("zplane.morph", map01(newState["morph"]), nullptr);































































    if (! newState.hasProperty("zplane.resonance") && newState.hasProperty("resonance"))































        newState.setProperty("zplane.resonance", map01(newState["resonance"]), nullptr);































































    if (! newState.hasProperty("style.mix") && newState.hasProperty("mix"))































        newState.setProperty("style.mix", map01(newState["mix"]), nullptr);































































    if (! newState.hasProperty("style.variant") && newState.hasProperty("style"))































    {































        const int oldStyle = (int) (float) newState["style"]; // 0=Air,1=Velvet,2=Focus































        const int mapped = juce::jlimit(0, 3, oldStyle + 1);   // 0=Neutral,1=Air,2=Velvet,3=Focus































        newState.setProperty("style.variant", mapped, nullptr);































    }































































    if (! newState.hasProperty("auto.morph")) newState.setProperty("auto.morph", true, nullptr);

    if (! newState.hasProperty("auto.morphDepth")) newState.setProperty("auto.morphDepth", 0.30f, nullptr);

    if (! newState.hasProperty("auto.morphRateHz")) newState.setProperty("auto.morphRateHz", 0.30f, nullptr);

    if (! newState.hasProperty("auto.morphSync")) newState.setProperty("auto.morphSync", 5, nullptr);

    if (! newState.hasProperty("auto.morphRetrig")) newState.setProperty("auto.morphRetrig", false, nullptr);

    apvts.replaceState (newState);































}































































//==============================================================================































juce::AudioProcessorValueTreeState::ParameterLayout































MorphEngineAudioProcessor::createParameterLayout()































{































    using namespace juce;































































    std::vector<std::unique_ptr<RangedAudioParameter>> params;































































    // zplane.model































    params.push_back(std::make_unique<AudioParameterChoice>(































        ParameterID{ "zplane.model", 1 },































        "Model",































        StringArray{ "Vowel Ae↔Oo", "Bell↔Cluster", "Low LP↔Formant" },































        0 // default: Vowel































    ));































































    // zplane.morph  (0..1)































    params.push_back(std::make_unique<AudioParameterFloat>(































        ParameterID{ "zplane.morph", 1 }, "Morph",































        NormalisableRange<float>{ 0.0f, 1.0f, 0.0f, 1.0f }, // linear































        0.35f,































        String(), nullptr, nullptr































    ));































































    // zplane.cutoff (0..1 normalized, but show Hz text)































    {































        NormalisableRange<float> cutoffRange{































            0.0f, 1.0f, 0.0f, 1.0f,































            // convertFrom0To1































            [](float x){ return x; },































            // convertTo0To1































            [](float x){ return x; }































        };































































        params.push_back(std::make_unique<AudioParameterFloat>(































            ParameterID{ "zplane.cutoff", 1 }, "Cutoff",































            cutoffRange,































            normFromHz(1200.0f), // ~1.2 kHz default































            String(),































            // Text -> value































            [](const String& text, float& out){































                auto t = text.trim().toLowerCase();































                auto hz = t.endsWith("khz") ? t.dropLastCharacters(3).getFloatValue()*1000.0f































                        : t.endsWith("hz")  ? t.dropLastCharacters(2).getFloatValue()































                        : t.getFloatValue();































                out = normFromHz(juce::jlimit(25.0f, 16000.0f, hz));































                return true;































            },































            // Value -> text































            [](float value, int)































            {































                const float hz = hzFromNorm(value);































                return hz >= 1000.0f ? String(hz / 1000.0f, 2) + " kHz"































                                     : String(juce::roundToInt(hz)) + " Hz";































            }































        ));































    }































































    // zplane.resonance (0..1)































    params.push_back(std::make_unique<AudioParameterFloat>(































        ParameterID{ "zplane.resonance", 1 }, "Resonance",































        NormalisableRange<float>{ 0.0f, 1.0f, 0.0f, 0.6f }, // gentle skew toward low values































        0.35f































    ));































































    // Auto morph modulation































    params.push_back(std::make_unique<AudioParameterBool>(































        ParameterID{ "auto.morph", 1 }, "Auto Morph", true));































































    params.push_back(std::make_unique<AudioParameterFloat>(































        ParameterID{ "auto.morphDepth", 1 }, "Auto Morph Depth",































        NormalisableRange<float>{ 0.0f, 1.0f, 0.0f, 1.0f },































        0.30f));































































    params.push_back(std::make_unique<AudioParameterFloat>(































        ParameterID{ "auto.morphRateHz", 1 }, "Auto Morph Rate (Hz)",































        NormalisableRange<float>{ 0.05f, 5.0f, 0.0f, 0.4f },































        0.30f));































































    params.push_back(std::make_unique<AudioParameterChoice>(































        ParameterID{ "auto.morphSync", 1 }, "Auto Morph Sync",































        StringArray{ "Off", "4 bars", "2 bars", "1 bar", "1/2", "1/4", "1/8", "1/16" },































        5));































































    params.push_back(std::make_unique<AudioParameterBool>(































        ParameterID{ "auto.morphRetrig", 1 }, "Auto Morph Retrig", false));































































    // style.variant (Choice)































    params.push_back(std::make_unique<AudioParameterChoice>(































        ParameterID{ "style.variant", 1 }, "Style",































        StringArray{ "Neutral", "Air", "Velvet", "Focus" },































        2 // default: Velvet































    ));































































    // style.mix (0..1)































    params.push_back(std::make_unique<AudioParameterFloat>(































        ParameterID{ "style.mix", 1 }, "Mix",































        NormalisableRange<float>{ 0.0f, 1.0f, 0.0f, 1.0f },































        1.0f































    ));































































    return { params.begin(), params.end() };































}































































//==============================================================================































void MorphEngineAudioProcessor::setSmootherTimes(double sr)

{

    smMorph.reset(sr, 0.020);  // 20 ms

    smCutoff.reset(sr, 0.030); // 30 ms

    smReso.reset(sr, 0.040);   // 40 ms

    smMix.reset(sr, 0.010);    // 10 ms

    smAutoDepth.reset(sr, 0.020);



    smMorph.setCurrentAndTargetValue(apvts.getRawParameterValue("zplane.morph")->load());

    smCutoff.setCurrentAndTargetValue(apvts.getRawParameterValue("zplane.cutoff")->load());

    smReso.setCurrentAndTargetValue(apvts.getRawParameterValue("zplane.resonance")->load());

    smMix.setCurrentAndTargetValue(apvts.getRawParameterValue("style.mix")->load());

    smAutoDepth.setCurrentAndTargetValue(apvts.getRawParameterValue("auto.morphDepth")->load());

}



double MorphEngineAudioProcessor::beatsPerCycleFromSyncIndex(int syncIndex, int timeSigNumerator, int timeSigDenominator)

{

    if (syncIndex <= 0 || timeSigNumerator <= 0 || timeSigDenominator <= 0)

        return 0.0;



    const double beatsPerBar = timeSigNumerator * (4.0 / static_cast<double>(timeSigDenominator));



    switch (syncIndex)

    {

        case 1: return 4.0 * beatsPerBar;  // 4 bars

        case 2: return 2.0 * beatsPerBar;  // 2 bars

        case 3: return beatsPerBar;        // 1 bar

        case 4: return 2.0;                // half-note

        case 5: return 1.0;                // quarter-note

        case 6: return 0.5;                // eighth-note

        case 7: return 0.25;               // sixteenth-note

        default: return 0.0;

    }

}



void MorphEngineAudioProcessor::updateAutoMorphRateFromHostTempo()

{

    const int syncIdx = (int) *apvts.getRawParameterValue("auto.morphSync");

    if (syncIdx == 0)

    {

        morphLFO.setRateHz(*apvts.getRawParameterValue("auto.morphRateHz"));

        lastIsPlaying = false;

        return;

    }



    bool updated = false;



    if (auto* playHead = getPlayHead())

    {

        juce::AudioPlayHead::CurrentPositionInfo info;

        if (playHead->getCurrentPosition(info))

        {

            const double beatsPerCycle = beatsPerCycleFromSyncIndex(syncIdx, info.timeSigNumerator, info.timeSigDenominator);

            if (info.bpm > 0.0 && beatsPerCycle > 0.0)

            {

                const double secondsPerBeat = 60.0 / info.bpm;

                const double periodSeconds = beatsPerCycle * secondsPerBeat;

                const float rateHz = (float) juce::jlimit(0.01, 10.0, 1.0 / juce::jmax(1.0e-6, periodSeconds));

                morphLFO.setRateHz(rateHz);



                const bool retrig = (*apvts.getRawParameterValue("auto.morphRetrig") > 0.5f);

                if (retrig && info.isPlaying && !lastIsPlaying)
                    morphLFO.resetPhase(); // align LFO start with DAW transport



                lastIsPlaying = info.isPlaying;

                updated = true;

            }

        }

    }



    if (!updated)
    {
        morphLFO.setRateHz(*apvts.getRawParameterValue("auto.morphRateHz")); // host tempo unavailable: respect manual rate

        lastIsPlaying = false;

    }

}


































































//==============================================================================






























































































    auto* pMorph = apvts.getParameter("zplane.morph");































    auto* pCut   = apvts.getParameter("zplane.cutoff");































    auto* pReso  = apvts.getParameter("zplane.resonance");































    auto* pMix   = apvts.getParameter("style.mix");































































    auto setParam = [](juce::AudioProcessorParameter* p, float normTarget)































    {































        p->beginChangeGesture();































        p->setValueNotifyingHost(juce::jlimit(0.0f, 1.0f, normTarget));































        p->endChangeGesture();































    };































































    // Push host-visible changes (so macros can be recorded)































    setParam(pMorph, tMorph);































    setParam(pCut,   tCut);































    setParam(pReso,  tReso);































    setParam(pMix,   tMix);































































    // Also push smoother targets immediately (no click; short ramps)































    smMorph.setTargetValue(tMorph);































    smCutoff.setTargetValue(tCut);































    smReso.setTargetValue(tReso);































    smMix.setTargetValue(tMix);































































    applyingStyle.store(false);































}































































//==============================================================================































// This creates new instances of the plugin..































juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()































{































    return new MorphEngineAudioProcessor();































}































